/* AoC 2024 17 - intcode! */

glbPC=0;
glbRegA=0;
glbRegB=0;
glbRegC=0;
glbProgram=[];
glbOutBuf="";

fn readInput()
{
    //sarr=readTextFileLineByLine("d:\prova\aoc2024\aoc17.2024.test.txt");
    sarr=readTextFileLineByLine("d:\prova\aoc2024\aoc17.2024.txt");
    return sarr;
}

fn parseProgram(arr)
{
    foreach (row in arr)
    {
        if (row.find("Register A: ")!=-1)
        {
            sVal="";
            idx=12;
            while (idx<row.length)
            {
                sVal+=row[idx];
                idx+=1;
            }
            glbRegA=toInteger(sVal);
        }
        if (row.find("Register B: ")!=-1)
        {
            sVal="";
            idx=12;
            while (idx<row.length)
            {
                sVal+=row[idx];
                idx+=1;
            }
            glbRegB=toInteger(sVal);
        }
        if (row.find("Register C: ")!=-1)
        {
            sVal="";
            idx=12;
            while (idx<row.length)
            {
                sVal+=row[idx];
                idx+=1;
            }
            glbRegC=toInteger(sVal);
        }
        if (row.find("Program")!=-1)
        {
            sVal="";
            idx=8;
            while (idx<row.length)
            {
                sVal+=row[idx];
                idx+=1;
            }
            sArr=sVal.split(",");
            foreach (opcode in sArr)
            {
                glbProgram.add(toInteger(opcode));
            }
        }
    }
}

fn getComboOperand()
{
    op=glbProgram[glbPC+1];

    if (op<4)
    {
        return op;
    }
    if (op==4)
    {
        return glbRegA;
    }
    if (op==5)
    {
        return glbRegB;
    }
    if (op==6)
    {
        return glbRegC;
    }

    print("this should not happen");
    return -1;
}

fn getPowerOf2(n)
{
    if (n==0)
    {
        return 1;
    }
    
    rez=1;
    idx=0;
    while (idx<n)
    {
        rez*=2;
        idx+=1;
    }

    return rez;
}

fn executeADV()
{
    combo=getComboOperand();
    pow=getPowerOf2(combo);
    res=glbRegA/pow;
    glbRegA=res;
}

fn executeBDV()
{
    combo=getComboOperand();
    pow=getPowerOf2(combo);
    res=glbRegA/pow;
    glbRegB=res;
}

fn executeCDV()
{
    combo=getComboOperand();
    pow=getPowerOf2(combo);
    res=glbRegA/pow;
    glbRegC=res;
}

fn executeBST()
{
    combo=getComboOperand();
    combo%=8;
    glbRegB=combo;
}

fn executeJNZ()
{
    if (glbRegA!=0)
    {
        lit=glbProgram[glbPC+1];
        glbPC=lit;
    }
    else
    {
        glbPC+=2;
    }
}

fn executeBXL()
{
    lit=glbProgram[glbPC+1];
    glbRegB=glbRegB^lit;
}

fn executeBXC()
{
    rc=glbRegC;
    glbRegB=glbRegB^rc;
}

fn executeOUT()
{
    combo=getComboOperand();
    combo%=8;
    //print(combo,",");
    glbOutBuf+=toString(combo);
    glbOutBuf+=",";
}

fn executeProgram()
{
    halted=false;

    while (!halted)
    {
        opcode=glbProgram[glbPC];

        if (opcode==0)
        {
            // adv
            executeADV();
            glbPC+=2;
        }
        if (opcode==1)
        {
            // bxl
            executeBXL();
            glbPC+=2;
        }
        if (opcode==2)
        {
            // bst
            executeBST();
            glbPC+=2;
        }
        if (opcode==3)
        {
            // jnz
            executeJNZ();
        }
        if (opcode==4)
        {
            // bxc
            executeBXC();
            glbPC+=2;
        }
        if (opcode==5)
        {
            // out
            executeOUT();
            glbPC+=2;
        }
        if (opcode==6)
        {
            // bdv
            executeBDV();
            glbPC+=2;
        }
        if (opcode==7)
        {
            // cdv
            executeCDV();
            glbPC+=2;
        }

        if (glbPC>=glbProgram.length)
        {
            halted=true;
        }
    }
}

fn part1(arr)
{
    parseProgram(arr);

    print("A:",glbRegA," B:",glbRegB," C:",glbRegC," Program:",glbProgram);
    executeProgram();

    print(glbOutBuf);
    print("A:",glbRegA," B:",glbRegB," C:",glbRegC," Program:",glbProgram);
}

fn part2(arr)
{
    parseProgram(arr);
    print("A:",glbRegA," B:",glbRegB," C:",glbRegC," Program:",glbProgram);

    sProg="";
    idx=0;
    while (idx<glbProgram.length)
    {
        sProg+=toString(glbProgram[idx]);
        sProg+=",";
        idx+=1;
    }

    //print("SProg:",sProg);

    aVal=200000;
    while (true)
    {
        print("regA is ",aVal);

        glbRegA=aVal;
        glbPC=0;
        glbRegB=0;
        glbRegC=0;
        glbOutBuf="";
        executeProgram();

        print("Result:",glbOutBuf);

        if (glbOutBuf==sProg)
        {
            print("Fount!");
            return;
        }

        aVal+=1;
    }
}

fn main(params)
{
    input=readInput();
    //part1(input);
    part2(input);
}
